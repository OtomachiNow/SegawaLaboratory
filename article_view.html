<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>瀬川研究室</title>
    <!-- MathJax -->
    <script>
        window.MathJax = {
            loader: { load: ['[tex]/physics', '[tex]/mathtools', '[tex]/ams', '[tex]/noerrors', '[tex]/bussproofs'] },
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                packages: {'[+]': ['bussproofs', 'physics', 'mathtools', 'ams']}
            },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <!-- Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="header width-constraint">
    <h1 id="site-title-header"><a href="index.html">読み込み中...</a></h1>
</div>

<div class="main-container width-constraint">
    <h1 id="article-title">読み込み中...</h1>
    <span id="article-date"></span>
    <div id="article-content"></div>
</div>

<footer class="foot width-constraint">
    &copy; 瀬川研究室
</footer>

<script>
    async function loadArticle() {
        const urlParams = new URLSearchParams(window.location.search);
        const articleId = urlParams.get('p');

        if (!articleId) {
            document.getElementById('article-title').textContent = '記事が指定されていません。';
            return;
        }

        try {
            const configRes = await fetch('./config.json');
            const config = await configRes.json();
            const speakers = config.speakers || {};
            
            document.title = config.site_title || "記事";
            const siteTitleLink = document.querySelector("#site-title-header a");
            if(siteTitleLink) siteTitleLink.textContent = config.site_title || "瀬川研究室";

            const response = await fetch(`./posts/${articleId}.json`);
            if (!response.ok) throw new Error("記事データが見つかりません。");
            const article = await response.json();

            document.getElementById('article-title').textContent = article.title;
            document.getElementById('article-date').textContent = article.date;

            const contentArea = document.getElementById('article-content');
            contentArea.innerHTML = ''; 
            
            // 小説モード判定
            const isNovel = article.type === 'novel';
            if (isNovel) {
                contentArea.classList.add('novel-mode');
            } else {
                contentArea.classList.remove('novel-mode');
            }

            // 要素生成関数（再帰対応）
            const renderElements = (elements, container) => {
                elements.forEach(item => {
                    if (item.type === 'dialogue') {
                        if (isNovel) {
                            const p = document.createElement('p');
                            p.className = 'novel-text';
                            p.innerHTML = item.content;
                            container.appendChild(p);
                        } else {
                            const row = document.createElement('div');
                            row.className = 'dialogue-row';
                            const side = item.side || 'left';
                            row.classList.add(side);
        
                            const speakerKey = item.speaker.trim();
                            const profile = speakers[speakerKey] || { color: '#f0f0f0', icon: '' };
                            
                            const icon = document.createElement('div');
                            icon.className = 'icon';
                            if (profile.icon) {
                                icon.style.backgroundImage = `url(${profile.icon})`;
                                icon.textContent = '';
                            } else {
                                icon.textContent = speakerKey.charAt(0);
                            }
                            icon.style.backgroundColor = profile.color;
        
                            const bubble = document.createElement('div');
                            bubble.className = 'bubble';
                            bubble.innerHTML = item.content;
                            if (profile.color) {
                                bubble.style.backgroundColor = profile.color;
                            }
        
                            row.appendChild(icon);
                            row.appendChild(bubble);
                            container.appendChild(row);
                        }
                    
                    } else if (item.type === 'heading') {
                        const heading = document.createElement('h2');
                        heading.className = 'section-heading';
                        heading.textContent = item.content;
                        container.appendChild(heading);
    
                    } else if (item.type === 'text') {
                        const p = document.createElement('p');
                        p.className = isNovel ? 'novel-text' : 'narrative-text';
                        p.innerHTML = item.content;
                        container.appendChild(p);
    
                    } else if (item.type === 'math') {
                        const div = document.createElement('div');
                        div.className = 'article-math';
                        div.innerHTML = item.content;
                        container.appendChild(div);
    
                    } else if (item.type === 'code') {
                        const pre = document.createElement('pre');
                        const code = document.createElement('code');
                        if (item.language) code.className = `language-${item.language}`;
                        code.textContent = item.content;
                        pre.appendChild(code);
                        container.appendChild(pre);
    
                    } else if (item.type === 'box') {
                        const box = document.createElement('div');
                        box.className = 'article-box';
                        const t = item.title || "";
                        if (t.includes("定義")) box.classList.add("box-def");
                        else if (t.includes("定理")) box.classList.add("box-thm");
                        else if (t.includes("証明")) box.classList.add("box-proof");
                        else if (t.includes("まとめ")) box.classList.add("box-summary");
                        else if (t.includes("宿題")) box.classList.add("box-hw");
    
                        if (item.title) {
                            const title = document.createElement('div');
                            title.className = 'box-title';
                            title.textContent = item.title;
                            box.appendChild(title);
                        }
                        const body = document.createElement('div');
                        body.className = 'box-body';
                        
                        // 再帰的描画または文字列表示
                        if (item.children) {
                            renderElements(item.children, body);
                        } else {
                            body.innerHTML = item.content;
                        }
                        
                        box.appendChild(body);
                        container.appendChild(box);
    
                    } else if (item.type === 'fold') {
                        const details = document.createElement('details');
                        
                        const summary = document.createElement('summary');
                        summary.textContent = item.summary || "詳細を表示";
                        details.appendChild(summary);
                        
                        const body = document.createElement('div');
                        body.className = 'fold-body';
                        
                        if (item.children) {
                            renderElements(item.children, body);
                        } else {
                            body.innerHTML = item.content || "";
                        }
                        
                        details.appendChild(body);
                        container.appendChild(details);

                    } else if (item.type === 'truth') {
                        const table = document.createElement('table');
                        table.className = 'truth-table';
                        item.rows.forEach((rowItems, index) => {
                            const tr = document.createElement('tr');
                            rowItems.forEach(cellText => {
                                const cell = document.createElement(index === 0 ? 'th' : 'td');
                                cell.innerHTML = cellText;
                                tr.appendChild(cell);
                            });
                            table.appendChild(tr);
                        });
                        container.appendChild(table);
                    }
                });
            };

            // メイン描画実行
            renderElements(article.data, contentArea);

            // 前後ナビゲーションの生成
            try {
                const tocRes = await fetch('./posts/toc.json');
                if (tocRes.ok) {
                    const toc = await tocRes.json();
                    
                    // 現在の記事の情報を取得
                    const [cat, id] = articleId.split('/');
                    let currentEntry = null;
                    if (toc[cat]) {
                        currentEntry = toc[cat].find(a => a.id === articleId);
                    }

                    let targetList = [];
                    
                    // StoryOrderがある場合 -> ストーリーモード（全ジャンルのorder順）
                    if (currentEntry && currentEntry.order && currentEntry.order > 0) {
                        let allArticles = [];
                        Object.keys(toc).forEach(catKey => {
                            const articles = toc[catKey]
                                .filter(a => a.order && a.order > 0)
                                .map(a => ({...a, cat: catKey}));
                            allArticles = allArticles.concat(articles);
                        });
                        allArticles.sort((a, b) => a.order - b.order);
                        targetList = allArticles;
                    
                    } else if (toc[cat]) {
                        // StoryOrderがない場合 -> ゼミモード（同ジャンル内順）
                        targetList = toc[cat];
                    }

                    // リスト内で現在の記事を探して前後を特定
                    if (targetList.length > 0) {
                        const currentIdx = targetList.findIndex(item => item.id === articleId);
                        
                        if (currentIdx !== -1) {
                            const prev = targetList[currentIdx - 1];
                            const next = targetList[currentIdx + 1];
                            
                            const createNav = () => {
                                const nav = document.createElement('div');
                                nav.className = 'article-nav';
                                
                                const prevLink = document.createElement('div');
                                prevLink.className = 'nav-prev';
                                if (prev) {
                                    prevLink.innerHTML = `<a href="article_view.html?p=${prev.id}">${prev.title}</a>`;
                                } else {
                                    prevLink.textContent = " ";
                                }
                                
                                const nextLink = document.createElement('div');
                                nextLink.className = 'nav-next';
                                if (next) {
                                    nextLink.innerHTML = `<a href="article_view.html?p=${next.id}">${next.title}</a>`;
                                } else {
                                    nextLink.textContent = " ";
                                }
                                
                                nav.appendChild(prevLink);
                                nav.appendChild(nextLink);
                                return nav;
                            };

                            const titleArea = document.querySelector('#article-date');
                            if (titleArea && titleArea.parentNode) {
                                titleArea.parentNode.insertBefore(createNav(), titleArea.nextSibling);
                            }
                            
                            contentArea.appendChild(createNav());
                        }
                    }
                }
            } catch (e) { console.log("Nav error:", e); }

            // MathJax 3 でレンダリング (ロード待ち対応)
            const renderMath = () => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise([contentArea]).catch((err) => console.log('MathJax error: ' + err));
                } else {
                    setTimeout(renderMath, 100);
                }
            };
            renderMath();

            if (window.hljs) {
                contentArea.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });
            }

        } catch (error) {
            console.error('Failed to load article:', error);
            document.getElementById('article-content').innerHTML = `<div style="color:red;padding:20px;background:#fff;border:1px solid red;"><h3>読み込みエラー</h3><p>${error.message}</p></div>`;
        }
    }

    loadArticle();
</script>
<script>
    if (window.location.hostname === "localhost") {
        const evtSource = new EventSource("/_livereload/events");
        evtSource.onmessage = function(event) {
            if (event.data === "reload") location.reload();
        };
    }
</script>
</body>
</html>